{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Causal Discovery via Partitioning","text":"<p>This page serves as the documentation for the code underlying the following paper on causal discovery:</p>"},{"location":"#causal-discovery-over-high-dimensional-structured-hypothesis-spaces-with-causal-graph-partitioning","title":"\"Causal Discovery over High-Dimensional Structured Hypothesis Spaces with Causal Graph Partitioning\"","text":""},{"location":"#abstract","title":"Abstract","text":"<p>The aim in many sciences is to understand the mechanisms that underlie the observed distribution of variables, starting from a set of initial hypotheses. Causal discovery allows us to infer mechanisms as sets of cause and effect relationships in a generalized way \u2013 without necessarily tailoring to a specific domain. Causal discovery algorithms search over a structured hypothesis space, defined by the set of directed acyclic graphs, to find the graph that best explains the data. For high-dimensional problems, however, this search becomes intractable and scalable algorithms for causal discovery are needed to bridge the gap. In this paper, we define a novel causal graph partition that allows for divide-and-conquer causal discovery with theoretical guarantees. We leverage the idea of a superstructure \u2013 a set of learned or existing candidate hypotheses \u2013 to partition the search space. We prove under certain assumptions that learning with a causal graph partition always yields the Markov Equivalence Class of the true causal graph. We show our algorithm achieves comparable accuracy and a faster time to solution for biologically-tuned synthetic networks and networks up to \\(10^4\\) variables. This makes our method applicable to gene regulatory network inference and other domains with high-dimensional structured hypothesis spaces.</p>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Ashka Shah (University of Chicago)</li> <li>Adela DePavia (University of Chicago)</li> <li>Nathaniel Hudson (University of Chicago, Argonne National Laboratory)</li> <li>Ian Foster (University of Chicago, Argonne National Laboratory)</li> <li>Rick Stevens (University of Chicago, Argonne National Laboratory)</li> </ul>"},{"location":"#citing-our-work","title":"Citing Our Work","text":"<p>If you use any code or outputs of this work, please the paper via the following BibTeX:</p> <pre><code>@article{shah2025causal,\n  title = {Causal Discovery over High-Dimensional Structured Hypothesis Spaces with Causal Graph Partitioning},\n  author = {Shah, Ashka and DePavia, Adela and Hudson, Nathaniel and Foster, Ian and Stevens, Rick},\n  journal = {Transactions on Machine Learning Research (TMLR)},\n  year = {2025},\n}\n</code></pre>"},{"location":"reference/","title":"cd_v_partition","text":"<p>Causal Discovery Partitioning (cd_v_partition) Package</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cd_v_partition</li> <li>causal_discovery</li> <li>config</li> <li>experiment</li> <li>fusion</li> <li>overlapping_partition</li> <li>types</li> <li>utils</li> <li>vis_experiment</li> <li>vis_partition</li> </ul>"},{"location":"reference/causal_discovery/","title":"causal_discovery","text":""},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.pc_local_learn","title":"pc_local_learn","text":"<pre><code>pc_local_learn(\n    subproblem: tuple[np.ndarray, pd.DataFrame],\n    use_skel: bool,\n) -&gt; np.ndarray\n</code></pre> <p>PC algorithm for a subproblem</p> <p>Local skeleton is ignored for PC. Defaults alpha=1e-3, 8 cores</p> PARAMETER  DESCRIPTION <code>subproblem</code> <p>Tuple (local skeleton, local observational data)</p> <p> TYPE: <code>tuple[ndarray, DataFrame]</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: local estimated adjancency matrix</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.ges_local_learn","title":"ges_local_learn","text":"<pre><code>ges_local_learn(\n    subproblem: tuple[np.ndarray, pd.DataFrame],\n    use_skel: bool,\n) -&gt; np.ndarray\n</code></pre> <p>GES algorithm for subproblem</p> <p>Use the local skeleton to restrict the search space</p> PARAMETER  DESCRIPTION <code>subproblem</code> <p>local skeleton, local observational data</p> <p> TYPE: <code>tuple[ndarray, DataFrame]</code> </p> <code>use_skel</code> <p>Uses skeleton, if True; otherwise False.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: local estimated adjacency matrix</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.rfci_local_learn","title":"rfci_local_learn","text":"<pre><code>rfci_local_learn(\n    subproblem: tuple[np.ndarray, pd.DataFrame],\n    use_skel: bool,\n) -&gt; np.ndarray\n</code></pre> <p>RFCI algorithm for a subproblem</p> <p>Converts the estimated PAG to a MAG, from which bi-directed edges are removed resulting in a DAG. Local skeleton is ignored for RFCI. Defaults to alpha=1e-3, 8 cores</p> PARAMETER  DESCRIPTION <code>subproblem</code> <p>(local skeleton, local observational data)</p> <p> TYPE: <code>tuple[ndarray, DataFrame]</code> </p> <code>use_skel</code> <p>Uses skeleton, if True; otherwise False.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: local estimated adjancency matrix</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.rfci_pag_local_learn","title":"rfci_pag_local_learn","text":"<pre><code>rfci_pag_local_learn(\n    subproblem: tuple[np.ndarray, pd.DataFrame],\n    use_skel: bool,\n) -&gt; np.ndarray\n</code></pre> <p>RFCI algorithm for a subproblem</p> <p>Local skeleton is ignored for RFCI. Defaults to alpha=1e-3, 8 cores</p> PARAMETER  DESCRIPTION <code>subproblem</code> <p>(local skeleton, local observational data)</p> <p> TYPE: <code>tuple[ndarray, DataFrame]</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: local estimated adjancency matrix</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.dagma_local_learn","title":"dagma_local_learn","text":"<pre><code>dagma_local_learn(\n    subproblem: tuple[np.ndarray, pd.DataFrame],\n    use_skel: bool,\n) -&gt; np.ndarray\n</code></pre> <p>Dagma algorithm for a subproblem</p> <p>Faster version of NOTEARS with log-det acyclicity characterization</p> PARAMETER  DESCRIPTION <code>subproblem</code> <p>local skeleton, local observational data</p> <p> TYPE: <code>tuple[ndarray, DataFrame]</code> </p> <code>use_skel</code> <p>Uses skeleton, if True; otherwise False.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: locally estimated adjancency matrix</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.pc","title":"pc","text":"<pre><code>pc(\n    data: pd.DataFrame,\n    skel: np.ndarray,\n    outdir: Path | str,\n    alpha: float = 0.001,\n    num_cores: int = 8,\n) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Python wrapper for the PC algorithm.</p> PARAMETER  DESCRIPTION <code>data</code> <p>DataFrame containing observational and interventional samples. Must contain a column named 'target' which specifies the index of the node that was intervened on to obtain the sample (assumes single interventions only). This indexes from 1 for R convenience. For observational samples the corresponding target should be 0. For PC this column is ignored, but exists for uniformity with interventional learners like SP-GIES</p> <p> TYPE: <code>DataFrame</code> </p> <code>skel</code> <p>An optional initial skeleton with dimensions \\(p \\times p\\).</p> <p> TYPE: <code>ndarray</code> </p> <code>outdir</code> <p>Directory to save adjacency matrix to.</p> <p> TYPE: <code>Path | str</code> </p> <code>alpha</code> <p>Significance threshold to trim edges. Defaults to 1e-3.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.001</code> </p> <code>num_cores</code> <p>Number of cpu cores to use during skeleton step of the PC algorithm. Defaults to 8.</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> RETURNS DESCRIPTION <code>tuple[ndarray, ndarray]</code> <p>A tuple containing two numpy arrays of dimensionality \\(p \\times p\\). The former <code>np.ndarray</code> represents the adjacency matrix for the CPDAG; the latter represents the significance level of each edge.</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.rfci","title":"rfci","text":"<pre><code>rfci(\n    data: pd.DataFrame,\n    skel: np.ndarray,\n    outdir: Path | str,\n    alpha: float = 0.001,\n    num_cores: int = 8,\n) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Python wrapper for the RFCI algorithm (faster version of FCI).</p> PARAMETER  DESCRIPTION <code>data</code> <p>DataFrame containing observational and interventional samples. Must contain a column named 'target' which specifies the index of the node that was intervened on to obtain the sample (assumes single interventions only). This indexes from 1 for R convenience. For observational samples the corresponding target should be 0. For PC this column is ignored, but exists for uniformity with interventional learners like SP-GIES</p> <p> TYPE: <code>DataFrame</code> </p> <code>skel</code> <p>An optional initial skeleton with dimensions \\(p \\times p\\).</p> <p> TYPE: <code>ndarray</code> </p> <code>outdir</code> <p>Directory to save adjacency matrix to.</p> <p> TYPE: <code>Path | str</code> </p> <code>alpha</code> <p>Significance threshold to trim edges. Defaults to 1e-3.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.001</code> </p> <code>num_cores</code> <p>Number of cpu cores to use during skeleton step of the PC algorithm. Defaults to 8.</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> RETURNS DESCRIPTION <code>tuple[ndarray, ndarray]</code> <p>A tuple containing two numpy arrays of dimensionality \\(p \\times p\\). The former <code>np.ndarray</code> represents the adjacency matrix for the CPDAG; the latter represents the significance level of each edge.</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.mag2dag","title":"mag2dag","text":"<pre><code>mag2dag(mag: np.ndarray) -&gt; np.ndarray\n</code></pre> <p>Convert a MAG adjacency matrix to a DAG by removing bidirected edges</p> PARAMETER  DESCRIPTION <code>mag</code> <p>Adjancency matrix for MAG, contains directed and bidirected edges</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Adjacency for corresponding DAG without bidirected edges</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.cu_pc","title":"cu_pc","text":"<pre><code>cu_pc(\n    data: pd.DataFrame,\n    outdir: Path | str,\n    alpha: float = 0.001,\n) -&gt; tuple[np.ndarray, np.ndarray] | None\n</code></pre> <p>Python wrapper for cuPC. CUDA implementation of the PC algorithm</p> PARAMETER  DESCRIPTION <code>data</code> <p>DataFrame containing observational and interventional samples. Must contain a column named 'target' which specifies the index of the node that was intervened on to obtain the sample (assumes single interventions only). This indexes from 1 for R convenience. For observational samples the corresponding target should be 0. For PC this column is ignored, but exists for uniformity with interventional learners like SP-GIES</p> <p> TYPE: <code>DataFrame</code> </p> <code>outdir</code> <p>The directory to save adjacency matrix to.</p> <p> TYPE: <code>Path | str</code> </p> <code>alpha</code> <p>Significance threshold to trim edges. Defaults to 1e-3.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.001</code> </p> RETURNS DESCRIPTION <code>tuple[ndarray, ndarray] | None</code> <p>Tuple of numpy arrays of dimension \\(p \\times p\\). The former array is the adjacency matrix for the CPDAG; the latter represents the significance level of each edge.</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.sp_gies","title":"sp_gies","text":"<pre><code>sp_gies(\n    data: pd.DataFrame,\n    outdir: Path | str,\n    alpha: float = 0.001,\n    skel: np.ndarray = None,\n    use_pc: bool = True,\n    multifactor_targets: list[list[Any]] = None,\n    adaptive: bool = True,\n)\n</code></pre> <p>Python wrapper for SP-GIES. Uses skeleton estimation to restrict edge set to GIES learner</p> PARAMETER  DESCRIPTION <code>data</code> <p>DataFrame containing observational and interventional samples. Must contain a column named 'target' which specifies the index of the node that was intervened on to obtain the sample (assumes single interventions only). This indexes from 1 for R convenience. For observational samples the corresponding target should be 0.</p> <p> TYPE: <code>DataFrame</code> </p> <code>outdir</code> <p>The directory to save the final adjacency matrix named <code>sp-gies-adj_mat.csv</code>. Set to None to skip saving files.</p> <p> TYPE: <code>Path | str</code> </p> <code>alpha</code> <p>Significance threshold to trim edges.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.001</code> </p> <code>skel</code> <p>An optional initial skeleton with dimensions \\(p \\times p\\).</p> <p> TYPE: <code>ndarray</code> DEFAULT: <code>None</code> </p> <code>use_pc</code> <p>A flag to indicate if skeleton estimation should be done with the PC. If <code>False</code> and no skel is specified, then assumed no skeleton i.e., reverts to GIES algorithm. Will use the GPU accelerated version of the PC if available, otherwise reverts to pcalg implementation of PC.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>multifactor_targets</code> <p>An optional list of lists for when there are multinode targets. In this case it is assumed that the 'target' column of the data DataFrame contains the index into this list.</p> <p> TYPE: <code>list[list[Any]]</code> DEFAULT: <code>None</code> </p> <code>adaptive</code> <p>If <code>True</code>, uses the 'triples' for the adaptive argument for the GIES algorithm.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <p>Array representing the adjacency matrix for the final learned graph.</p>"},{"location":"reference/causal_discovery/#cd_v_partition.causal_discovery.weight_colliders","title":"weight_colliders","text":"<pre><code>weight_colliders(adj_mat: np.ndarray, weight: int = 1)\n</code></pre> <p>Find and add weights to collider sets in a given adjacency matrix. Collider sets are x-&gt;y&lt;-z when there is no edge between \\((x,z)\\).</p> PARAMETER  DESCRIPTION <code>adj_mat</code> <p>\\(p \\times p\\) adjacency matrix.</p> <p> TYPE: <code>ndarray</code> </p> <code>weight</code> <p>Edges that are part of a collider set are weighted with this weight.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <p>An array representing the weighted adjacency matrix.</p>"},{"location":"reference/config/","title":"config","text":""},{"location":"reference/config/#cd_v_partition.config.SimulationSpec","title":"SimulationSpec  <code>dataclass</code>","text":""},{"location":"reference/config/#cd_v_partition.config.SimulationSpec.to_yaml","title":"to_yaml  <code>classmethod</code>","text":"<pre><code>to_yaml(outfile: Path | str) -&gt; None\n</code></pre> <p>Saves spec to yaml file.</p> PARAMETER  DESCRIPTION <code>outfile</code> <p>The path for where to save the yaml file.</p> <p> TYPE: <code>Path | str</code> </p>"},{"location":"reference/config/#cd_v_partition.config.SimulationConfig","title":"SimulationConfig  <code>dataclass</code>","text":""},{"location":"reference/config/#cd_v_partition.config.SimulationConfig.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[SimulationSpec]\n</code></pre> <p>Iterates through all the combinations of iterable items in config (see <code>itertools.product</code>).</p> RETURNS DESCRIPTION <code>Iterator[SimulationSpec]</code> <p>Iterator item.</p>"},{"location":"reference/config/#cd_v_partition.config.SimulationConfig.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml(outfile: Path | str) -&gt; None\n</code></pre> <p>Saves config to yaml file.</p> PARAMETER  DESCRIPTION <code>outfile</code> <p>The path for where to save the yaml file.</p> <p> TYPE: <code>Path | str</code> </p>"},{"location":"reference/config/#cd_v_partition.config.SimulationConfig.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(path: Path | str) -&gt; SimulationConfig\n</code></pre> <p>Reads a <code>.yaml</code> file to instantiate a <code>SimulationConfig</code> object.</p> PARAMETER  DESCRIPTION <code>path</code> <p>Path of the <code>.yaml</code> file.</p> <p> TYPE: <code>Path | str</code> </p> RETURNS DESCRIPTION <code>SimulationConfig</code> <p>An instance of <code>SimulationConfig</code>.</p>"},{"location":"reference/experiment/","title":"experiment","text":""},{"location":"reference/fusion/","title":"fusion","text":""},{"location":"reference/fusion/#cd_v_partition.fusion.remove_edges_not_in_ss","title":"remove_edges_not_in_ss","text":"<pre><code>remove_edges_not_in_ss(\n    target_graph: nx.DiGraph, ss_graph: nx.DiGraph\n) -&gt; nx.DiGraph\n</code></pre> <p>Remove edges from target_graph which do not exist in ss_graph</p> Notes <p>Final fusion step to merge subgraphs. In infinite data limit this is done by screening for conflicting edges during union over subgraphs.</p> PARAMETER  DESCRIPTION <code>target_graph</code> <p>the target directed graph</p> <p> TYPE: <code>DiGraph</code> </p> <code>ss_graph</code> <p>the superstructure</p> <p> TYPE: <code>DiGraph</code> </p> RETURNS DESCRIPTION <code>DiGraph</code> <p>nx.DiGraph: target_graph with only edges appearing in ss_graph</p>"},{"location":"reference/fusion/#cd_v_partition.fusion.no_partition_postprocess","title":"no_partition_postprocess","text":"<pre><code>no_partition_postprocess(\n    ss: np.ndarray,\n    est_adj_mat: np.ndarray,\n    ss_subset: bool = True,\n) -&gt; np.ndarray\n</code></pre> <p>Method to postprocess the graph when there is no partition.</p> <p>If the ss_subset flag is set then remove all edges that are not in the provided supserstructure, otherwise return the estimated adjacency matrix as is.</p> PARAMETER  DESCRIPTION <code>ss</code> <p>adjacency matrix for superstructure</p> <p> TYPE: <code>ndarray</code> </p> <code>est_adj_mat</code> <p>estimated adjacency matrix</p> <p> TYPE: <code>ndarray</code> </p> <code>ss_subset</code> <p>Flag to filter out edges not in the superstructure. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: The resultant graph as an adjancency matrix</p>"},{"location":"reference/fusion/#cd_v_partition.fusion.screen_projections","title":"screen_projections","text":"<pre><code>screen_projections(\n    ss: np.ndarray,\n    partition: dict[Any, Any],\n    local_cd_adj_mats: list[np.ndarray],\n    ss_subset: bool = True,\n    finite_lim: bool = True,\n    data: np.ndarray = None,\n    full_cand_set: bool = False,\n) -&gt; nx.DiGraph\n</code></pre> <p>Fuse subgraphs by taking the union and resolving conflicts by favoring no edge over directed edge. Leave bidirected edges as is. This is the method used for 'infinite' data limit problems.</p> PARAMETER  DESCRIPTION <code>ss</code> <p>adjacency matrix for the super structure</p> <p> TYPE: <code>ndarray</code> </p> <code>partition</code> <p>the partition as a dictionary</p> <p> TYPE: <code>dict[Any, Any]</code> </p> <code>local_cd_adj_mats</code> <p>list of adjacency matrices for each local subgraph</p> <p> TYPE: <code>list[ndarray]</code> </p> <code>ss_subset</code> <p>whether to only include edges in global_graph which are in ss.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>finite_lim</code> <p>whether to include adaptations to finite limit setting, including resolving bidirected edges using RIC score and cycle detection/deletion.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>data</code> <p>if finite_lim==True, we need data to use RIC score.</p> <p> TYPE: <code>None or ndarray</code> DEFAULT: <code>None</code> </p> <code>full_cand_set</code> <p>ignore, unused flag.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Returns:     nx.DiGraph: the final global directed graph with all nodes and edges</p>"},{"location":"reference/fusion/#cd_v_partition.fusion.screen_projections_finite_lim_postprocessing","title":"screen_projections_finite_lim_postprocessing","text":"<pre><code>screen_projections_finite_lim_postprocessing(\n    ss_graph: nx.DiGraph,\n    global_graph: nx.DiGraph,\n    partition: dict[Any, Any],\n    ss_subset=True,\n    data=None,\n) -&gt; nx.DiGraph\n</code></pre> <p>Adapts results of screen_projections to finite limit setting by resolving bidirected edges using RIC score and cycle detection/deletion.</p> PARAMETER  DESCRIPTION <code>ss_graph</code> <p>directed graph for super structure</p> <p> TYPE: <code>DiGraph</code> </p> <code>global_graph</code> <p>estimated directed graph</p> <p> TYPE: <code>DiGraph</code> </p> <code>partition</code> <p>the partition as a dictionary</p> <p> TYPE: <code>dict[Any, Any]</code> </p> <code>ss_subset</code> <p>whether to only include edges in global_graph which are in ss.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>data</code> <p>we need data to use RIC score</p> <p> TYPE: <code>None or ndarray</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DiGraph</code> <p>nx.DiGraph: the final estimated global directed graph</p>"},{"location":"reference/fusion/#cd_v_partition.fusion.fusion","title":"fusion","text":"<pre><code>fusion(\n    ss: np.ndarray,\n    partition: dict[Any, Any],\n    local_cd_adj_mats: list[np.ndarray],\n    data: np.ndarray,\n    ss_subset=False,\n    finite_lim: bool = False,\n    full_cand_set: bool = False,\n)\n</code></pre> <p>Fuse subgraphs by taking the union and resolving conflicts by taking the lower scoring edge. Ensure that the edge added does not create a cycle</p> <p>Resolving bidirected edges using RIC score and cycle detection/deletion.</p> PARAMETER  DESCRIPTION <code>ss</code> <p>adjacency matrix for the super structure</p> <p> TYPE: <code>ndarray</code> </p> <code>partition</code> <p>the partition as a dictionary</p> <p> TYPE: <code>dict[Any, Any]</code> </p> <code>local_cd_adj_mats</code> <p>list of adjacency matrices for each local subgraph.</p> <p> TYPE: <code>list[ndarray]</code> </p> <code>ss_subset</code> <p>whether to only include edges in global_graph which are in ss.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>finite_lim</code> <p>ignore, unused flag</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>data</code> <p>if finite_lim==True, we need data to use RIC score.</p> <p> TYPE: <code>None or ndarray</code> </p> <code>full_cand_set</code> <p>Flag to condition on the all nodes in the graph when determining if an edge exists between two nodes in different subsets. If <code>False</code>, will only condition on nddes in overlapping sets. Default to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <p>nx.DiGraph: the final global directed graph with all nodes and edges</p>"},{"location":"reference/fusion/#cd_v_partition.fusion.fusion_basic","title":"fusion_basic","text":"<pre><code>fusion_basic(\n    partition: dict[Any, Any],\n    local_cd_adj_mats: list[np.ndarray],\n) -&gt; nx.DiGraph\n</code></pre> <p>Fuse subgraphs by taking the union and resolving conflicts by taking the higher weighted edge (for now). Eventually we want to the proof to inform how the merge happens here and we also want to consider finite data affects.</p> PARAMETER  DESCRIPTION <code>partition</code> <p>the partition as a dictionary {comm_id : [nodes]}</p> <p> TYPE: <code>dict</code> </p> <code>local_cd_adj_mats</code> <p>list of adjacency matrices for each local subgraph</p> <p> TYPE: <code>list[ndarray]</code> </p> RETURNS DESCRIPTION <code>DiGraph</code> <p>The final global directed graph with all nodes and edges</p>"},{"location":"reference/overlapping_partition/","title":"overlapping_partition","text":""},{"location":"reference/overlapping_partition/#cd_v_partition.overlapping_partition.modularity_partition","title":"modularity_partition","text":"<pre><code>modularity_partition(\n    adj_mat: np.ndarray,\n    data: pd.DataFrame,\n    resolution: int = 1,\n    cutoff: int = 1,\n    best_n: int = None,\n)\n</code></pre> <p>Creates disjoint partition by greedily maximizing modularity. Using networkx built-in implementaiton.</p> PARAMETER  DESCRIPTION <code>adj_mat</code> <p>the adjacency matrix for the superstructure</p> <p> TYPE: <code>ndarray</code> </p> <code>data</code> <p>unused parameter</p> <p> TYPE: <code>DataFrame</code> </p> <code>resolution</code> <p>resolution parameter, trading off intra- versus inter-group edges.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>cutoff</code> <p>lower limit on number of communities before termination</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>best_n</code> <p>upper limit on number of communities before termination</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>the estimated partition as a dictionary {comm_id : [nodes]}</p>"},{"location":"reference/overlapping_partition/#cd_v_partition.overlapping_partition.expansive_causal_partition","title":"expansive_causal_partition","text":"<pre><code>expansive_causal_partition(\n    adj_mat: np.ndarray,\n    data: pd.DataFrame,\n    resolution: int = 1,\n    cutoff: int = 1,\n    best_n: int = None,\n)\n</code></pre> <p>Creates a causal partition by adding the outer-boundary of each cluster to that cluster.</p> <p>First uses greedy modularity to create a disjoint partition, then adds the outer-boundary of each cluster to create a causal partition</p> PARAMETER  DESCRIPTION <code>adj_mat</code> <p>the adjacency matrix for the superstructure</p> <p> TYPE: <code>ndarray</code> </p> <code>data</code> <p>unused parameter</p> <p> TYPE: <code>Any</code> </p> <code>resolution</code> <p>resolution parameter, trading off intra- versus inter-group edges.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>cutoff</code> <p>lower limit on number of communities before termination</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>best_n</code> <p>upper limit on number of communities before termination</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>the causal partition as a dictionary {comm_id : [nodes]}</p>"},{"location":"reference/overlapping_partition/#cd_v_partition.overlapping_partition.rand_edge_cover_partition","title":"rand_edge_cover_partition","text":"<pre><code>rand_edge_cover_partition(\n    adj_mat: np.ndarray,\n    data: pd.DataFrame,\n    resolution: int = 1,\n    cutoff: int = 1,\n    best_n: int = None,\n)\n</code></pre> <p>Creates a random edge covering partition.</p> <p>Uses greedy modularity to create a disjoint partition. Then, randomly chooses cut edges and randomly assigns endpoints to communities. Recursively adds any shared endpoints to the same community</p> PARAMETER  DESCRIPTION <code>adj_mat</code> <p>Adjacency matrix for the graph</p> <p> TYPE: <code>ndarray</code> </p> <code>data</code> <p>unused parameter</p> <p> TYPE: <code>DataFrame</code> </p> <code>resolution</code> <p>resolution parameter, trading off intra- versus inter-group edges.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>cutoff</code> <p>lower limit on number of communities before termination</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>best_n</code> <p>upper limit on number of communities before termination</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>the overlapping partition as a dictionary {comm_id : [nodes]}</p>"},{"location":"reference/overlapping_partition/#cd_v_partition.overlapping_partition.hierarchical_partition","title":"hierarchical_partition","text":"<pre><code>hierarchical_partition(\n    adj_mat: np.ndarray, max_community_size: float = 0.5\n)\n</code></pre> <p>Creates disjoint partition via heirarchical community detection</p> PARAMETER  DESCRIPTION <code>adj_mat</code> <p>the adjacency matrix for the superstructure</p> <p> TYPE: <code>ndarray</code> </p> <code>max_community_szie</code> <p>controls the size of the largest community in returned partition See networkx documentation for more information.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>the estimated partition as a dictionary {comm_id : [nodes]}</p>"},{"location":"reference/overlapping_partition/#cd_v_partition.overlapping_partition.oslom_algorithm","title":"oslom_algorithm","text":"<pre><code>oslom_algorithm(\n    nodes: typing.Iterable,\n    dat_file: Path | str,\n    oslom_dir: Path | str,\n    structure_type: str | None = \"dag\",\n) -&gt; dict\n</code></pre> <p>Overlapping partitioning methods which take an input graph (superstructure) and partition nodes according to an objective overlapping nodes ideally render the partitions conditionally independent.</p> PARAMETER  DESCRIPTION <code>nodes</code> <p>...</p> <p> </p> <code>data_dir</code> <p>The directory containing the *.dat file which holds the edges of the structure to partition.</p> <p> TYPE: <code>Path | str</code> </p> <code>oslom_dir</code> <p>The directory containing the OSLOM binary</p> <p> TYPE: <code>Path | str</code> </p> <code>structure_type</code> <p>Specify the structure type as either the 'dag',  'superstructure', or 'superstructure_weighted'. If weighted then weights in the *.dat are used by OSLOM. Defaults to 'dag'.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>'dag'</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The estimated partition as a dictionary {comm_id : [nodes]}</p>"},{"location":"reference/overlapping_partition/#cd_v_partition.overlapping_partition.partition_problem","title":"partition_problem","text":"<pre><code>partition_problem(\n    partition: dict,\n    structure: np.ndarray,\n    data: pd.DataFrame,\n)\n</code></pre> <p>Split the graph structure and dataset according to the given graph partition.</p> PARAMETER  DESCRIPTION <code>partition</code> <p>the partition as a dictionary {comm_id : [nodes]}</p> <p> TYPE: <code>dict</code> </p> <code>structure</code> <p>the adjacency matrix for the initial structure</p> <p> TYPE: <code>ndarray</code> </p> <code>data</code> <p>the dataset, columns correspond to nodes in the graph.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <p>List of tuples holding the sub structure and data subsets for</p> <p>each partition.</p>"},{"location":"reference/overlapping_partition/#cd_v_partition.overlapping_partition.PEF_partition","title":"PEF_partition","text":"<pre><code>PEF_partition(\n    adj_mat: np.ndarray,\n    data: pd.DataFrame,\n    resolution: int = 1,\n    cutoff: int = 1,\n    best_n: int = None,\n    min_size_frac: float = 0.05,\n) -&gt; dict\n</code></pre> <p>Perform the modified hierarchical clustering on the data, as described in `Learning Big Gaussian Bayesian Networks: Partition, Estimation and Fusion'</p> PARAMETER  DESCRIPTION <code>adj_mat</code> <p>Adjacency matrix for the graph</p> <p> TYPE: <code>ndarray</code> </p> <code>data</code> <p>the dataset, columns correspond to nodes in the graph.</p> <p> TYPE: <code>DataFrame</code> </p> <code>resolution</code> <p>unused parameter</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>cutoff</code> <p>unused parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>best_n</code> <p>unuserd parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>min_size_frac</code> <p>determines the minimimum returned cluster size.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.05</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The estimated partition as a dictionary {comm_id : [nodes]}</p>"},{"location":"reference/types/","title":"types","text":""},{"location":"reference/types/#cd_v_partition.types.GraphKind","title":"GraphKind  <code>module-attribute</code>","text":"<pre><code>GraphKind = Literal[\n    \"erdos_renyi\",\n    \"small_world\",\n    \"scale_free\",\n    \"hierarchical\",\n    \"ecoli\",\n]\n</code></pre> <p>Kinds of graphs that are used for experimental results.</p>"},{"location":"reference/types/#cd_v_partition.types.TrueGraph","title":"TrueGraph","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Data for a true graph with a list of nodes and a list of edges.</p>"},{"location":"reference/types/#cd_v_partition.types.TrueGraph.nodes","title":"nodes  <code>instance-attribute</code>","text":"<pre><code>nodes: list[Node]\n</code></pre> <p>Nodes in the true graph.</p>"},{"location":"reference/types/#cd_v_partition.types.TrueGraph.edges","title":"edges  <code>instance-attribute</code>","text":"<pre><code>edges: list[Edge]\n</code></pre> <p>Edges in the true graph.</p>"},{"location":"reference/types/#cd_v_partition.types.Result","title":"Result","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Result of an experimental run.</p>"},{"location":"reference/types/#cd_v_partition.types.GeneratedGraph","title":"GeneratedGraph  <code>dataclass</code>","text":"<p>A sampled causal graph.</p>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#cd_v_partition.utils.directed_random_graph","title":"directed_random_graph","text":"<pre><code>directed_random_graph(\n    nnodes: int,\n    random_graph_model: Callable,\n    random_state: RandomState,\n    size=1,\n    as_list=False,\n) -&gt; DAG | list[DAG]\n</code></pre> <p>override graphical_models.rand.directed_random_graph to take in a random state</p>"},{"location":"reference/utils/#cd_v_partition.utils.sample","title":"sample","text":"<pre><code>sample(\n    gaussdag: GaussDAG,\n    random_state: RandomState,\n    nsamples: int = 1,\n) -&gt; np.array\n</code></pre> <p>Return a number of samples (specified by <code>nsamples</code>) from the graph.</p> PARAMETER  DESCRIPTION <code>gaussdag</code> <p>Gaussian DAG to sample from.</p> <p> TYPE: <code>GaussDAG</code> </p> <code>random_state</code> <p>Used for seeding and reproducibility.</p> <p> TYPE: <code>RandomState</code> </p> <code>nsamples</code> <p>Number of samples to return. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>array</code> <p>\\(nsamples \\times nnodes\\) matrix of samples.</p>"},{"location":"reference/utils/#cd_v_partition.utils.adj_to_edge","title":"adj_to_edge","text":"<pre><code>adj_to_edge(\n    adj: np.ndarray,\n    nodes: list[str],\n    ignore_weights: bool = False,\n)\n</code></pre> <p>Helper function to convert an adjacency matrix into an edge list. Optionally include weights so that the edge tuple is (i, j, weight).</p> PARAMETER  DESCRIPTION <code>adj</code> <p>Adjacency  matrix of dimensionality \\(p \\times p\\).</p> <p> TYPE: <code>ndarray</code> </p> <code>nodes</code> <p>List of node names\u2014in order corresponding to rows/cols of <code>adj</code>.</p> <p> TYPE: <code>list[str]</code> </p> <code>ignore_weights</code> <p>Ignore the weights if <code>True</code>; include them if <code>False</code>. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <p>Edge list (of nonzero values) from the given adjacency matrix.</p>"},{"location":"reference/utils/#cd_v_partition.utils.adj_to_dag","title":"adj_to_dag","text":"<pre><code>adj_to_dag(adj: np.ndarray) -&gt; nx.DiGraph\n</code></pre> <p>Helper function to convert an adjacency matrix into a directed graph.</p> PARAMETER  DESCRIPTION <code>adj</code> <p>Adjacency matrix of dimensionality \\(p \\times p\\).</p> <p> TYPE: <code>ndarray</code> </p> <code>nodes</code> <p>List of node names\u2014in order corresponding to rows/cols of <code>adj</code>.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>DiGraph</code> <p>Directed acyclic graph from the given adjacency matrix.</p>"},{"location":"reference/utils/#cd_v_partition.utils.edge_to_adj","title":"edge_to_adj","text":"<pre><code>edge_to_adj(\n    edges: list[tuple], nodes: list[str]\n) -&gt; np.ndarray\n</code></pre> <p>Helper function to convert an edge list into an adjacency matrix.</p> PARAMETER  DESCRIPTION <code>edges</code> <p>List of (i,j) tuples corresponding to directed edges.</p> <p> TYPE: <code>list[tuple]</code> </p> <code>nodes</code> <p>List of node names in order corresponding to rows/cols of adj.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Adjacency matrix.</p>"},{"location":"reference/utils/#cd_v_partition.utils.edge_to_dag","title":"edge_to_dag","text":"<pre><code>edge_to_dag(edges) -&gt; nx.DiGraph\n</code></pre> <p>Helper function to convert a list of edges into a Networkx DiGraph</p> PARAMETER  DESCRIPTION <code>edges</code> <p>Edge list of directed edges.</p> <p> TYPE: <code>list[tuple]</code> </p> RETURNS DESCRIPTION <code>DiGraph</code> <p>Directed acyclic graph.</p>"},{"location":"reference/utils/#cd_v_partition.utils.tpr_fpr_score","title":"tpr_fpr_score","text":"<pre><code>tpr_fpr_score(\n    y_true: np.ndarray | nx.DiGraph,\n    y_pred: np.ndarray | nx.DiGraph,\n) -&gt; tuple[float, float]\n</code></pre> <p>Calculate the true positive rate and false positive scores between a true graph and predicted graph using sklearn.roc_curve. We choose the point correponding to the maximum threshold i.e if the adjacency matrix only has 1s or 0s, the max threshold is 1 and the tpr corresponds to the number of correct 1s.</p> PARAMETER  DESCRIPTION <code>y_true</code> <p>Ground truth topology (either adjacency matrix or directed graph).</p> <p> TYPE: <code>ndarray | DiGraph</code> </p> <code>y_pred</code> <p>Estimated topology (either adjacency matrix or directed graph).</p> <p> TYPE: <code>ndarray | DiGraph</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Tuple of floats corresponding to true positive rate and false</p> <code>float</code> <p>positive rate in ROC curve at the maximum threshold value</p>"},{"location":"reference/utils/#cd_v_partition.utils.get_scores","title":"get_scores","text":"<pre><code>get_scores(\n    alg_names: list[str],\n    networks: list[np.ndarray] | list[nx.DiGraph],\n    ground_truth: np.ndarray | nx.DiGraph,\n    get_sid: bool = False,\n) -&gt; tuple[float, float, float, float, float]\n</code></pre> <p>Calculate metrics Structural Hamming Distance (SHD), Structural Interventional Distance (SID), AUC, TPR,FPR for a set of algorithms and networks. Also handles averaging over several sets of networks (e.g the random comparison averages over several different generated graphs)</p> PARAMETER  DESCRIPTION <code>alg_names</code> <p>list of algorithm names.</p> <p> TYPE: <code>list[str]</code> </p> <code>networks</code> <p>list of estimated graphs corresponding to algorithm names.</p> <p> TYPE: <code>list[ndarray] | list[DiGraph]</code> </p> <code>ground_truth</code> <p>the true graph to compare to.</p> <p> TYPE: <code>ndarray | DiGraph</code> </p> <code>get_sid</code> <p>flag to calculate SID which is computationally expensive, returned SID is 0 if this is <code>False</code>.</p> <p> TYPE: <code>bool) </code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[float, float, float, float, float]</code> <p>floats corresponding to SHD, SID, AUC, (TPR, FPR)</p> Notes <p>By default, we turn off sid, since it is computationally expensive.</p>"},{"location":"reference/utils/#cd_v_partition.utils.get_random_graph_data","title":"get_random_graph_data","text":"<pre><code>get_random_graph_data(\n    graph_type: str,\n    num_nodes: int,\n    nsamples: int,\n    iv_samples: int,\n    p: float,\n    m: int,\n    seed: int | RandomState = 42,\n    save: bool = False,\n    outdir: Path | str = None,\n) -&gt; tuple[\n    tuple[set[tuple], list[int], float, float], pd.DataFrame\n]\n</code></pre> <p>Create a random Gaussian DAG and corresponding observational and interventional dataset. Note that the generated topology with Networkx undirected, using graphical_models a causal ordering is imposed on this graph which makes it a DAG. Each node has a randomly sampled bias and variance from which Gaussian data is generated (children are sums of their parents). Save a data.csv file containing the observational and interventional data samples and target column Save a ground.txt file containing the edge list of the generated graph.</p> PARAMETER  DESCRIPTION <code>graph_type</code> <p>erdos_renyi, scale_free (Barabasi-Albert) or small_world (Watts-Strogatz).</p> <p> TYPE: <code>str</code> </p> <code>num_nodes</code> <p>number of nodes in the generated graph.</p> <p> TYPE: <code>int</code> </p> <code>nsamples</code> <p>number of observational samples to generate.</p> <p> TYPE: <code>int</code> </p> <code>iv_samples</code> <p>number of interventional samples to generate.</p> <p> TYPE: <code>int) </code> </p> <code>p</code> <p>probability of edge creation (erdos_renyi) or rewiring (small_world).</p> <p> TYPE: <code>float</code> </p> <code>m</code> <p>number of edges to attach from a new node to existing nodes (scale_free) or number of nearest neighbors connected in ring (small_world).</p> <p> TYPE: <code>int</code> </p> <code>seed</code> <p>random seed.</p> <p> TYPE: <code>int</code> DEFAULT: <code>42</code> </p> <code>save</code> <p>flag to save the dataset (data.csv) and graph (ground.txt).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>outdir</code> <p>directory to save the data to if save is <code>True</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Returns:     arcs (list of edges), nodes (list of node indices), bias         (bias terms for Gaussian generative model), var         (variance terms for Gaussian generative model), df         (pandas DataFrame containing sampled observational,         interventional data and target indices)</p>"},{"location":"reference/utils/#cd_v_partition.utils.get_data_from_graph","title":"get_data_from_graph","text":"<pre><code>get_data_from_graph(\n    nodes: list[str],\n    edges: list[tuple],\n    nsamples: int,\n    iv_samples: int,\n    bias: np.ndarray = None,\n    var: np.ndarray = None,\n    save: bool = False,\n    outdir: Path | str = None,\n    random_state: int | RandomState = 42,\n)\n</code></pre> <p>Get data set from a predefined graph using the Gaussian DAG generative model (same as get_random_graph_data) Save a data.csv file containing the observational and interventional data samples and target vector Save a ground.txt file containing the edge list of the generated graph Save a data.csv file containing the observational and interventional data samples and target column. Save a ground.txt file containing the edge list of the generated graph.</p> PARAMETER  DESCRIPTION <code>nodes</code> <p>list of node names</p> <p> TYPE: <code>list[str]</code> </p> <code>edges</code> <p>list of directed edge tuples (i,j) where i and j are in nodes</p> <p> TYPE: <code>list[tuple]</code> </p> <code>nsamples</code> <p>number of observational samples to generate</p> <p> TYPE: <code>int</code> </p> <code>iv_samples</code> <p>number of interventional samples to generate</p> <p> TYPE: <code>int) </code> </p> <code>save</code> <p>flag to save the dataset (data.csv) and graph (ground.txt)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>outdir</code> <p>directory to save the data to if save is True</p> <p> TYPE: <code>Path | str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>edges (list of edges), nodes (list of node indices), bias (bias terms for Gaussian generative model), var (variance terms for Gaussian generative model), df (pandas DataFrame containing sampled observational, interventional data and target indices).</p>"},{"location":"reference/utils/#cd_v_partition.utils.evaluate_partition","title":"evaluate_partition","text":"<pre><code>evaluate_partition(partition, G, nodes)\n</code></pre> <p>Evaluate the partition over a graph with the edge coverage and overlapping modularity scores.</p> PARAMETER  DESCRIPTION <code>partition</code> <p>keys are community ids, values are lists of nodes</p> <p> TYPE: <code>dict</code> </p> <code>G</code> <p>the original structure that is being partitioned</p> <p> TYPE: <code>DiGraph</code> </p> <code>nodes</code> <p>list of nodes in order of adjacency matrix</p> <p> TYPE: <code>list</code> </p>"},{"location":"reference/utils/#cd_v_partition.utils.delta_causality","title":"delta_causality","text":"<pre><code>delta_causality(\n    est_graph_serial, est_graph_partition, true_graph\n)\n</code></pre> <p>Calculate the difference in scores (SHD, AUC, SID, TPR_FPR) between the serial estimated grpah and the partitioned estimated graph. The difference is calculated as serial_score - partition_score.</p> PARAMETER  DESCRIPTION <code>est_graph_serial</code> <p>the estimated graph from running the causal discovery algorithm on the entire data and node set</p> <p> TYPE: <code>ndarray or DiGraph</code> </p> <code>est_graph_partition</code> <p>the estimated graph from running the causal discovery algorithm on the partitioned data and node sets</p> <p> TYPE: <code>ndarray or DiGraph</code> </p> <code>true_graph</code> <p>the ground truth graph to compare to</p> <p> TYPE: <code>ndarray or DiGraph</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Delta SHD, AUC, SID, TPR, FPR.</p> <p> TYPE: <code>(float, float, float, float, float)</code> </p> Notes <p>The sign here is relative to the serial implmentation (we do not take the aboslute value)</p>"},{"location":"reference/utils/#cd_v_partition.utils.create_k_comms","title":"create_k_comms","text":"<pre><code>create_k_comms(\n    graph_type: str,\n    n: int,\n    m_list: list[int],\n    p_list: list[int],\n    k: int,\n    rho: int = 0.01,\n    random_state: RandomState | int = 0,\n) -&gt; tuple[dict, nx.DiGraph]\n</code></pre> <p>Create a random network with k communities with the specified graph type and parameters. Create this by generating k disjoint communities and using preferential attachment. Remove any cycles to make this a DAG</p> PARAMETER  DESCRIPTION <code>graph_type</code> <p>erdos_renyi, scale_free (Barabasi-Albert) or small_world (Watts-Strogatz)</p> <p> TYPE: <code>str</code> </p> <code>n</code> <p>number of nodes per community</p> <p> TYPE: <code>int</code> </p> <code>m_list</code> <p>number of edges to attach from a new node to existing nodes (scale_free) or number of nearest neighbors connected in ring (small_world)</p> <p> TYPE: <code>list[int]</code> </p> <code>p_list</code> <p>probability of edge creation (erdos_renyi) or rewiring (small_world)</p> <p> TYPE: <code>list[float]</code> </p> <code>k</code> <p>number of communities</p> <p> TYPE: <code>int</code> </p> <code>rho</code> <p>Parameter to tune the strength of community structure. This is the fraction of total possible edges between communities. Defaults to 0.01</p> <p> TYPE: <code>int</code> DEFAULT: <code>0.01</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Tuple containing the following: (1) a dictionary storing the</p> <code>DiGraph</code> <p>community partitions and (2) the graph of the connected communities.</p>"},{"location":"reference/utils/#cd_v_partition.utils.correlation_superstructure","title":"correlation_superstructure","text":"<pre><code>correlation_superstructure(\n    data: pd.DataFrame,\n    seed: int | RandomState,\n    num_iterations: int = 100,\n) -&gt; np.ndarray\n</code></pre> <p>Creates a superstructure by calculating the correlation matrix from the data.</p> <p>A cutoff value is chosen using permutation testing: randomly shuffling the data amtrix and recalculating the correlation matrix over a specified number of iterations. The upper bound of the 95% confidence interval for the maximum value in each shuffled matrix is used as the threshold for the superstructure.</p> PARAMETER  DESCRIPTION <code>data</code> <p>sampled data set, each column is a random variable</p> <p> TYPE: <code>pd.DataFrame) </code> </p> <code>num_iterations</code> <p>number of iterations for permutation testing</p> <p> TYPE: <code>int) </code> DEFAULT: <code>100</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>an adjacency matrix for the superstructure we've created</p>"},{"location":"reference/utils/#cd_v_partition.utils.artificial_superstructure","title":"artificial_superstructure","text":"<pre><code>artificial_superstructure(\n    G_star_adj_mat: np.ndarray,\n    frac_retain_direction: float = 0.1,\n    frac_extraneous: float = 0.5,\n) -&gt; np.ndarray\n</code></pre> <p>Creates a superstructure by discarding some of the directions in edges of G_star and adding extraneous edges.</p> PARAMETER  DESCRIPTION <code>G_star_adj_mat</code> <p>the adjacency matrix for the target graph</p> <p> TYPE: <code>ndarray</code> </p> <code>frac_retain_direction</code> <p>what percentage of edges will retain their direction information</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>frac_extraneous</code> <p>adds frac_extraneous*m many additional edges, for m the number of edges in G_star</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>An adjacency matrix for the superstructure we've created</p>"},{"location":"reference/vis_experiment/","title":"vis_experiment","text":""},{"location":"reference/vis_experiment/#cd_v_partition.vis_experiment.load_iteration","title":"load_iteration","text":"<pre><code>load_iteration(data: np.ndarray, **kwargs) -&gt; list[Record]\n</code></pre> <p>Loads a single iteration (or Monte-Carlo) run from a result file.</p> PARAMETER  DESCRIPTION <code>data</code> <p>The <code>numpy</code> array that represents a single iteration of data. This is effectively a row-vector in terms of dimensionality.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>list[Record]</code> <p>A list of records (i.e., <code>dict[str, Any]</code>), with the 5  metrics of</p> <code>list[Record]</code> <p>interest (i.e., SHD, SId, AUC, TPR, and FPR) and the provided</p> <code>list[Record]</code> <p><code>kwargs</code>.</p>"},{"location":"reference/vis_experiment/#cd_v_partition.vis_experiment.read_chkpoints","title":"read_chkpoints","text":"<pre><code>read_chkpoints(\n    dir: Path | str,\n    eval_algs: list[str],\n    cd_alg: str,\n    num_trials: int,\n    save_sweep_values: Any,\n) -&gt; pd.DataFrame\n</code></pre> <p>summary</p> PARAMETER  DESCRIPTION <code>dir</code> <p>description</p> <p> TYPE: <code>Path | str</code> </p> <code>eval_algs</code> <p>description</p> <p> TYPE: <code>list[str]</code> </p> <code>cd_alg</code> <p>description</p> <p> TYPE: <code>str</code> </p> <code>num_trials</code> <p>description</p> <p> TYPE: <code>int</code> </p> <code>save_sweep_values</code> <p>description</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: description</p>"},{"location":"reference/vis_experiment/#cd_v_partition.vis_experiment.vis_experiment","title":"vis_experiment","text":"<pre><code>vis_experiment(\n    experiment_id: int,\n    dir: str,\n    eval_algs: list[str],\n    cd_alg: str,\n    num_trials: int,\n    save_sweep_param: str,\n    save_sweep_values: Any,\n)\n</code></pre> <p>Read checkpoints and visualize plots for scores from an experiment</p> <p>Plots the SHD, TPR and Time along the specified axis for the specified evaluation algorithms</p> PARAMETER  DESCRIPTION <code>experiment_id</code> <p>index of experiment, used to specify format of plot</p> <p> TYPE: <code>int</code> </p> <code>dir</code> <p>path to the save directory for the experiment</p> <p> TYPE: <code>str</code> </p> <code>eval_algs</code> <p>List of partitioning algorithms</p> <p> TYPE: <code>list[str]</code> </p> <code>cd_alg</code> <p>Name of the causal discovery algorithm e.g, GES</p> <p> TYPE: <code>str</code> </p> <code>num_trials</code> <p>Number of trials/graphs per spec</p> <p> TYPE: <code>int</code> </p> <code>save_sweep_param</code> <p>The name of the sweep parameter (x-axis label for plots)</p> <p> TYPE: <code>str</code> </p> <code>save_sweep_values</code> <p>The values for the sweep parameter (x-axis values for plots)</p> <p> TYPE: <code>Any</code> </p>"},{"location":"reference/vis_partition/","title":"vis_partition","text":""},{"location":"reference/vis_partition/#cd_v_partition.vis_partition.create_partition_plot","title":"create_partition_plot","text":"<pre><code>create_partition_plot(\n    G: nx.Graph | nx.DiGraph,\n    nodes: list[str],\n    partition: dict[int, list[int]],\n    save_name: Path | str,\n    ax=None,\n    node_size=1,\n    edge_width=2,\n)\n</code></pre> <p>Create plot of overlapping partitions with patches.</p> PARAMETER  DESCRIPTION <code>G</code> <p>Graph to plot.</p> <p> TYPE: <code>Graph | DiGraph</code> </p> <code>nodes</code> <p>List of node names.</p> <p> TYPE: <code>list[str]</code> </p> <code>partition</code> <p>Partition.</p> <p> TYPE: <code>dict[int, list[int]]</code> </p> <code>save_name</code> <p> TYPE: <code>Path | str</code> </p> RETURNS DESCRIPTION <p>...</p>"}]}